I"i:<p><strong>Two years </strong>have passed since the first works on Example42's NextGen modules and I think it's time to review what has been done, what has worked and what hasn't.</p>
<p>The NextGen modules layout has introduced various solutions and approaches to <strong>reusable modules design</strong> which have been more or less successful: some have been used also by other modules authors, some have been made obsolete by Puppet's evolution, some have remained practically unused.<br /><br />Some of the ideas used were already around or emerging, other were quite new and unexplored, some are still valid, others would probably be done differently now.</p>
<p>What I can say is that my main task of that module set has been achieved: I, and, afaik, various other people, use effortlessly the same modules unmodified on different environments and infrastructures: that's what I want from a reusable module.</p>
<h3>What worked, what failed, what could be better</h3>
<h5>Params lookup</h5>
<p>This is a function that is used on every main class parameter and allows choice on where data is defined: on an ENC (as Top Scope vars), Hiera or directly passed as parameters to the class. Dan Bode gave me the original idea, on which I added some frills like the&#160;possibility to look for a global variable after a module specific one. &#160;<br />Basically is the same concept of <strong>Puppet 3's data bindings</strong>, with the difference that it has been introduced before the release of Puppet 3 and it works on any version of Puppet &gt; 2.6.<br /><br />The point is that now, with Puppet 3 more and more used, such a function is quite redundant and introduces some extra calculation time that might be avoided.</p>
<h5>Alternatives for configuration files</h5>
<p>All the NextGen modules have params like <strong>template </strong>and&#160;<strong>source </strong>that let users decide how to provide configuration files. The usage of a parameter like template is now common and practically required for a reusable module, at those times it wasn't. I think this kind of params (eventually with a wider "<em><strong>content</strong></em>" one) must stay in a module that aims to be considered reusable.</p>
<p>Also there's the possibility to manage&#160;whole configuration dirs, with&#160;<strong>source_dir ,&#160;source_dir_purge</strong>, which even if not generally recommended with large amount of files to syncronize, it can be a valid solution in some cases.</p>
<h5>Decommissioning support</h5>
<p>To provide parameters that allow the removal of the managed resources (like '<strong>absent</strong>') is another possibility that at the times wasn't much spread and it's becoming more and more common. My only concern here is the unfortunate naming choice, something like '<em><strong>ensure</strong></em>' is definitively a better and clearer name.</p>
<h5>Service management options</h5>
<p>Params like <strong>disable</strong>, <strong>disableboot </strong>and <strong>service_autorestart </strong>were introduced to let users decide how to manage services startup and their behaviour when config file change. I've seen them being used also in other modules and this confirms me that they make sense, even if also in this case I think that the naming choice was quite poor.</p>
<h5>Multi OS support and user's override options</h5>
<p>Multi OS support was not new for modules also at the time, I consider it a <em>condicio sine qua non</em>, for a reusable module, and the params class pattern was probably the best way to manage it.<br />Now this is going to <a href="http://projects.puppetlabs.com/issues/16856" title="puppet should support data in modules">change</a>&#160;with Puppet 3.3.0 , Hiera 2 and data in modules, where a brand new world opens to module's internal data management.<br />NextGen modules also expose all the OS specific params as class parameters, so that the OS defaults values set in params.pp can be overridden by users: this has the consequence of giving more reusability options for edge cases but adds also a bunch of parameters which are rarely used, such as: <strong>package</strong>, <strong>service</strong>, <strong>config_file</strong>,&#160;<strong>config_dir</strong>,&#160;<strong>config_file_owner</strong>, <strong>config_file_group</strong>, <strong>config_file_mode </strong>... Probably I'd keep only the first 3 or 4 of these parameters, now.</p>
<h5>Integrated monitoring and firewalling options</h5>
<p>I firmly believe that a module should provide the possibility to automatically monitor and firewall the resources it installs and do it in a "<em><strong>tool neutral</strong></em>" way, that is it should not contain parameters related to specific monitoring or firewalling tools. I've seen this concept (mostly the firewalling integration) be reused in other modules like the PuppetLabs ones, and I think it's definitively worth to be followed. The current implementation, with the usage of meta classes like Example42's monitor and firewall ones, still doesn't satisfy me fully and also I'm wondering if and where it makes sense to expose in the module all the parameters required to make this work ( <strong>monitor </strong>, <strong>monitor_tool</strong>, <strong>monitor_target </strong>, <strong>firewall </strong>, <strong>firewall_tool </strong>, <strong>firewall_src </strong>, <strong>firewall_dst </strong>and other ones like <strong>port </strong>, <strong>protocol </strong>, <strong>pid_file </strong>, <strong>process </strong>, <strong>process_args </strong>).<br /><br />Probably the wonders and the evolution of the Puppet &#160;<a href="http://docs.puppetlabs.com/puppet/3/reference/lang_experimental_3_2.html" title="Language: Experimental Features">Future Parser</a>&#160;, which will probably be the default in Puppet 4, will allow better management of params like this, with the usage and manipulation of configuration hashes that would limit the exposure of a bunch of parameters and the possibility to freely expand them with tools specific settings.</p>
<h5>Puppi integration</h5>
<p>This has remained an incomplete work. One of Puppi's aims is to use Puppet's data to feed a CLI command. "<em>Puppet Knowledge to the Shell</em>" was my mantra, and I still think this can lead to powerful results. The problem is that the current Puppi still doesn't work with NextGen Puppi integration (which is quite ridiculous, I admit) and the Puppi 2 which should support it is still incomplete. Also in the whole picture is missing a sane web front end for all the data that Puppi might collect on the system.<br /><br />It's all in the TODO list, but it's there for quite a long time, so I would rate the Puppi integration in the NextGen modules a <strong>failure</strong>.<br />Also the Puppi integration bring a bunch of other hardly used parameters like&#160;<strong>data_dir</strong>,&#160;<strong>log_dir</strong>,&#160;<strong>log_file</strong>&#160;and various ones already used for other functions.<br /><br />Note that you can still use Puppi for local puppi checks (setting it as monitor_tool) and for its other main function, application deployment, and that works quite well.</p>
<h5>Templates + Options Hash pattern</h5>
<p>I don't like the idea of adding a parameter to a class for each/most configuration option of the managed application, as you might end up adding a large amount of parameters to your module.<br />For this reason a quite open solution, if you really want all your configurations as data, is to provide a custom <strong>template</strong> and feed it with a single configuration hash via the <strong>options</strong> parameter.<br /><br />The puppi module (which you can consider the stdlib for Example42 modules) provides also a useful function, <a href="https://github.com/example42/puppi/blob/master/lib/puppet/parser/functions/options_lookup.rb" title="Options lookup">options_lookup</a>&#160;, contributed by Mike Novak, which allows easy usage of the options hash in an erb template. I'd like to see such an option in the stdlib.<br /><br />Personally I've not used too much this solution (generally I just provide a custom template that has encoded most of the specific settings and uses variables only the most important or qualifying ones), &#160;and I suppose is the same for others, also because in the modules there weren't sample templates that could show some usage patterns.</p>
<h5>Debug, audit and noops</h5>
<p>Some extra juice was added to the modules.<br />A <strong>debug</strong> parameter which dumps the whole class scope in a file. Useful, even if I rarely use it.<br />An <strong>audit_only</strong> parameter which was supposed to let the user define to audit the changes of the module. Never used it.<br />A <strong>noops</strong> parameter, introduced later, which is supposed to run per module noops (the noop metaparameter on the class has no effects on the contained resources). The idea makes sense, imho, the implementation was buggy and incidentally I've spent the last weekend fixing it on the modules who have this parameters, so, it's time to update them!</p>
<h5>Custom and dependency classes</h5>
<p>In all the modules there's a <strong>my_class</strong> parameter which allows you to define a custom class where you can place extra resources related to the module. Strictly speaking this is not needed, as you can place these resources directly in the role/service class that uses the module, but the idea is to have whatever is related to a module (config files, extra resources and so on) defined in a single point. Not essential but not harmful, imho.</p>
<p>Recently I've also started to introduce a parameter like <strong>dependency_class</strong>, which allows the definition of a custom class where resources needed by the module, but provided by other modules, could be placed. The idea is to give the user the possibility to use other modules&#160;different from the Example42 ones&#160;to manage the required resources&#160;&#160;( database operations, extra repos , virtual host defines ... ). I think that such an option is useful to allow better integration with other modules and to allow usage of single Example42 modules without entering into dependencies hell with modules from other authors.</p>
<h5>Modules cloning via templates / blueprints&#160;</h5>
<p>All the nextgen modules are made in a way that is easy to rename them, make some sed works and have a brand new <strong>full featured</strong> modules with limited effort. <br />Actually there's a script available to <a href="https://github.com/example42/Example42-tools/blob/master/module_clone.sh"><strong>clone</strong></a> Example42 modules that allows easy creation of a new module based on an existing ones.<br /><br />More than once someone has told me that if a module can be generated from a blueprint then there should be a saner way to inject data into a single module layout without making a new module every time.<br />Actually the idea behind a structure that allows quick cloning is not to have modules that are all the same (with some changes in the params class) but to have a solid and standard base from which to build features specific to the application managed.</p>
<p>This approach has permitted also other authors to create modules based on the NextGen layout and actually various of them, like the ones from <a href="https://github.com/netmanagers">Netmanagers</a>&#160;guys or <a href="https://github.com/mburger">Marcus Burger</a>&#160;or others, have been integrated and linked in the <a href="https://github.com/example42/puppet-modules-nextgen">NextGen modules set</a> and are managed directly from the original authors. That's a model I like and hope to see it grow.</p>
<h5>Docs, Lints and Spec tests</h5>
<p>All the modules have <strong>PuppetDoc</strong> compliant documentation, and are tested via <strong>Puppet Lint</strong> and <strong>Rspec Puppet</strong>. This is basically a good thing, and it's effortlessly cloned from module to module. What I must admit here is that not always I've given much care to the documentation or the test coverage of the new, module specific, features. The result is that documentation looks often all the same and the tests have not that much added value.<br />This is something that I'd like to better care in the future.</p>
<h3>What's next</h3>
<p>The future parser and Hiera 2 may really change radically the way we design our modules and there's so much development in the Puppet ecosystem that is clear that we are moving to another transition, where the DSL is radically opened to new solutions and patterns.</p>
<p>&#160;If I had to rewrite the NextGen modules now I'd do some things differently: no params_lookup, better naming choices, less parameters, but I think this layout still works well with current setups and actually I'm using it in production in many different places.<br /><br />There will be sooner or later a third iteration of Example42 modules:<br />- The <a href="https://github.com/example42/puppet-modules/tree/1.0"><strong>first</strong> one</a>, was done in pre-2.6 era, it has some interesting concepts, for the times, and various drawbacks. I'd not use it anywhere now. Actually I should remove the OldGen modules remained in the <a href="https://github.com/example42/puppet-modules">Official</a> Example42 modules set.<br />- The <a href="https://github.com/example42/puppet-modules-nextgen"><strong>second</strong> one</a>, the NextGen, is strongly based on parametrized classes, requires Puppet &gt; 2.6 and works well with Puppet 3, even if the params_lookup is redundant.<br />- The <strong>third</strong> one has yet to be done, and it might be Puppet 4 only compliant (or at least Puppet &gt; 3.3), trying to fully use the future parser, data in modules and what will be available.<br />It will also probably use rspec-system, adhere to <a href="https://github.com/stdmod">stdmod</a> naming standards, whatever they will be, and be based on stdlib.<br /><br />Also I'll definitively try to find a more shared and open development effort, so that applications specific experts can create and be maintainers of the modules they need and use.</p>
<p>There's time to experiment on that, some patterns reveal their degree of success or failure only when they have been used and tested in different conditions.<br />Puppet 4 is expected for the end of the year, but some time will pass before it gets massively used in production, so I presume the NextGen modules are here to stay for many months.</p>
<p>I'd love to discuss about this and what has been written here directly on <a href="https://groups.google.com/forum/#!topic/example42-puppet-modules/B0R0w7iA46s">Example42 Puppet Modules</a> Google group (I definitely surrendered at the idea on managing comments on this spam-infested blog).</p>
<p>And thanks for reading up to here!&#160;<br /><br />I'm not good in writing short blog posts :-)</p>
:ET